#!/usr/bin/perl -w

#
# 2012.04.12  Brian Finley <bfinley@lenovo.com>
# - created to generate p2p labels for UChicago install by Rochester CSC
# 2014.01.13  Brian Finley <bfinley@lenovo.com>
# - updated to be more flexible
# - handle striping of some tier2 devices across a tier1 device
# - handle different uplink counts for each tier2 device
# - handle nodes directly connected to tier1 device (by treating as a tier2 with very
#   few ports)
# 2014.01.14  Brian Finley <bfinley@lenovo.com>
# - updated total number of tier1 device cards
# 2014.03.10  Brian Finley <bfinley@lenovo.com>
# - Added --force, --output-file, --columns
# 2015.02.05  Brian Finley <bfinley@lenovo.com>
#   - future comments to be added via the git log
#

use strict;
use Getopt::Long;
use File::Basename;
use Data::Dumper;

my $progname = basename($0);
my $pkgname = 'HPC Goodies';
my $version_number = '0.4.7';

our @output;

my $columns = 1;
GetOptions(
    "help"                  => \my $help,
    "version"               => \my $version,
    "v|verbose"             => \my $verbose,
    "columns=i"             =>    \$columns,
    "output-file=s"         => \my $output_file,
    "c|config|input-file=s" => \my $conf,
    "delimiter"             => \my $delimiter,
    "cabling|cables=s"      => \my $cabling,
    "d|debug"               => \my $debug,
    "create-template"       => \my $create_template,
) or usage() and exit(1);

if ( defined $help ) {
    usage();
    exit 0;
}
elsif ( defined $version ) {
    version();
    exit 0;
}
elsif ( defined $create_template ) {
    create_template_file($output_file);
    print_output();
    exit 0;
}
elsif ( defined $cabling ) {

    $cabling = lc $cabling;

    unless($cabling =~ m/^(above|below)$/) {
        usage();
        print "\n";
        print "  >> Try --cabling above\n";
        print "      or --cabling below\n";
        print "\n";
        exit 1;
    }
}

if ( ! defined $conf ) {
    usage();
    print "\n";
    print "  >> Try --config FILENAME\n";
    print "      or --create-template\n";
    print "\n";
    exit 1;
}

$delimiter = '-' unless( defined $delimiter );

my %cables;
my %floor_plan;
my %devices;

# Assign defaults
my %dimensions;
$dimensions{cold_isle}           = 3;           # meters
$dimensions{hot_isle}            = 2;           # meters
$dimensions{rack_unit}           = .04445;      # meters
$dimensions{cable_slack_to_port} = .25;         # meters
$dimensions{overhead_buffer}     = 3.7691;      # meters
$dimensions{under_floor_buffer}  = 3.857999;    # meters
$dimensions{rack_width}          = .6;          # 1 floor tile  in meters
$dimensions{rack_depth}          = 1.2;         # 2 floor tiles in meters
$dimensions{rack_height_in_ru}   = 42;          # height in rack units
#
# TODO:
# - for each rack, indicate front or back cabling
# - handle putting copper cables on outside of switches
#   - outside-in, inside-out, low-to-high, high-to-low
# 


my $stanza_terminator = '^(\s+|$)';
my $comment = '^#';
my $port_indicator = 'P';

my %p2p_assignments;
my %p2p_cable_counts;
my %last_higher_tier_device_number_assigned;

read_config_file();
#    print Dumper($devices{'R3-U12-L'});
#    print Dumper($devices{'R4-U11'}); 
#    exit 7;
#create_ordered_list_of_downlinks_by_tier();
make_p2p_assignments();
create_output();
print_output();

exit 0;



sub make_p2p_assignments {

    foreach my $tier (reverse sort keys %{$devices{tier}}) {
        foreach my $lower_tier_label ( sort keys %{$devices{tier}{$tier}{label}} ) {

            next   unless(   $devices{$lower_tier_label}{free_uplinks}  );
            while( scalar( @{$devices{$lower_tier_label}{free_uplinks}} ) > 0 ) {

                my $port = shift @{$devices{$lower_tier_label}{free_uplinks}};
                my ($higher_tier_label, $higher_tier_port) = get_higher_tier_target_port($lower_tier_label, $port);

                my $lower_tier_port_label = "$lower_tier_label-$port_indicator$port";
                my $higher_tier_port_label = "$higher_tier_label-$port_indicator$higher_tier_port";

                $devices{$lower_tier_label}{uplink_port_assignments}{$port}                 = $higher_tier_port_label;
                $devices{$higher_tier_label,}{downlink_port_assignments}{$higher_tier_port} = $lower_tier_port_label;

                my $cable_length = choose_cable_length($lower_tier_label, $higher_tier_label);

                $p2p_assignments{$lower_tier_port_label}{port1_label} = $lower_tier_port_label;
                $p2p_assignments{$lower_tier_port_label}{port2_label} = $higher_tier_port_label;
                $p2p_assignments{$lower_tier_port_label}{cable_length} = $cable_length;
                $p2p_cable_counts{$cable_length}++;

                print "$cable_length uplink from $lower_tier_port_label -> $higher_tier_port_label\n" if($verbose);
            } 
        }
    }

    return 1;
}


sub get_higher_tier_target_port {

    my $lower_tier_label    = shift;
    my $lower_tier_port     = shift;

    my $higher_tier = $devices{$lower_tier_label}{tier} - 1;

    my $side;
    my $other_side;
    if($devices{$lower_tier_label}{extra_id}) {    # must be a 1/2U node -- which side is it on?
        if($devices{$lower_tier_label}{extra_id} eq 'L') {
            $side = 'low';
            $other_side = 'high';
        } else {
            $side = 'high';
            $other_side = 'low';
        }
    } else {
        my $center_port_low = $devices{$lower_tier_label}{total_ports} / 2;    # E.g.: 18 on a 36port switch
        if($lower_tier_port > $center_port_low) {
            $side = 'high';
            $other_side = 'low';
        } else {
            $side = 'low';
            $other_side = 'high';
        }
    }

#print "Dev count tier $higher_tier: $devices{tier}{$higher_tier}{downlink_device_count}\n";
#foreach (sort numerically keys %{$devices{tier}{$higher_tier}{downlink_devices}} ) {
#    print "dev_num $_\n";
#}
#exit 7;

    my $higher_tier_label;
    my $higher_tier_port;

    my $device_number = 1;
    if($last_higher_tier_device_number_assigned{$lower_tier_label}) {
        $device_number = $last_higher_tier_device_number_assigned{$lower_tier_label} + 1;
    }

    my $safety_count = 1;
    until($safety_count == $devices{tier}{$higher_tier}{downlink_device_count}) {  # iterate until we've hit each higher tier device once

        if($device_number > $devices{tier}{$higher_tier}{downlink_device_count}) {
            $device_number = 1;
        }

#print "dev_num $device_number\n";
        $higher_tier_label = $devices{tier}{$higher_tier}{downlink_devices}{$device_number};

        # Prefer a port on the same side, but try the other side if not...
        if( scalar(@{$devices{$higher_tier_label}{free_downlinks}{$side}}) > 0 ) {
            $higher_tier_port = shift @{$devices{$higher_tier_label}{free_downlinks}{$side}};
            $last_higher_tier_device_number_assigned{$lower_tier_label} = $device_number;
#print "S: $side, \tL-H $lower_tier_port-$higher_tier_port, LHTDNA: $device_number,   LTL: $lower_tier_label, LTP: $lower_tier_port, HTL: $higher_tier_label, HTP $higher_tier_port, DN $device_number, SN $safety_count\n";
            return ($higher_tier_label, $higher_tier_port);
        } 
        elsif( scalar(@{$devices{$higher_tier_label}{free_downlinks}{$other_side}}) > 0 ) {
            $higher_tier_port = shift @{$devices{$higher_tier_label}{free_downlinks}{$other_side}};
            $last_higher_tier_device_number_assigned{$lower_tier_label} = $device_number;
#print "S: $side, \tL-H $lower_tier_port-$higher_tier_port, LHTDNA: $device_number,   LTL: $lower_tier_label, LTP: $lower_tier_port, HTL: $higher_tier_label, HTP $higher_tier_port, DN $device_number, SN $safety_count\n";
            return ($higher_tier_label, $higher_tier_port);
        }
        $device_number++;
        $safety_count++;
    }

    return undef;   # if we get here, something went wrong
}


#
# Uplink Target is the port on the higher tier switch to which we will connect.
# The upstream end of the p2p.
#
# This subroutine is written from the perspective of the higher tier device
#
sub assign_uplink_targets {

    my $label = shift;

    my $chosen_ports_count = 0;
    until( $chosen_ports_count == $devices{$label}{uplink_port_count} ) {
        
        my $port1_label = get_next_free_uplink_port($label);
        my $port2_label = get_next_free_downlink_port($label, $port1_label);

        my $p2p = "$port1_label $port2_label";
        $p2p_assignments{$p2p}{port1_label} = $port1_label;
        $p2p_assignments{$p2p}{port2_label} = $port2_label;

        if($cabling) {
            my $cable_length = choose_cable_length($port1_label, $port2_label);
            $p2p_assignments{$p2p}{cable_length} = $cable_length;
        }

        $chosen_ports_count++;
    }

    return 1;
}


#
# Downlink Target is the port on the lower tier switch to which we will
# connect.  The downstream end of the p2p.
#
# This subroutine is written from the perspective of the higher tier device
#
#sub get_next_free_downlink_port {
#
#    my $label   = shift;
#    my $port    = shift;
#
#    my $side;
#    if($devices{$label}{port}{$port}) {
#        $side = $devices{$label}{port}{$port};
#    } else {
#        $side = 'low';
#    }
#
#    my $tier = $devices{$label}{tier} - 1;
#    my $downlink_port;
#    if(scalar(@{$devices{downlink_port_labels}{$side}{$tier}}) > 0) {
#        $downlink_port = shift @{$devices{downlink_port_labels}{$side}{$tier}};
#
#    } else {
#
#        if(scalar(@{$devices{downlink_port_labels}{low}{$tier}}) > 0) {
#            $downlink_port = shift @{$devices{downlink_port_labels}{low}{$tier}};
#
#        } elsif(scalar(@{$devices{downlink_port_labels}{high}{$tier}}) > 0) {
#            $downlink_port = shift @{$devices{downlink_port_labels}{high}{$tier}};
#
#        } else {
#            return undef;
#        }
#    }
#
#    #print "DEBUG: Next downlink port for Tier $devices{$label}{tier} is $downlink_port\n" if($debug);
#
#    return $downlink_port;
#
#    ## XXX incorporate this later... -BEF-
#    ##
#    ## See if there's an uplink device in this tier in the same rack as the downlink device
#    ##
#    #my $downlink_target_rackname = $devices{$label}{rackname};
#    #if( $devices{tier}{$tier}{rackname}{$downlink_target_rackname} ) {
#    #    # yes!
#    #    # prefer a device from here
#    #} else {
#    #    # no!
#    #}
#}


#sub get_next_free_uplink_port {
#
#    my $label = shift;
#
#    
#
#    return $port;
    #return 1;

    #my $port;
    #if(scalar(@{$devices{$label}{free_uplinks}}) > 0) {
    #    $port_label = shift @{$devices{$label}{free_uplinks}};
    #}
    #
    #return $port_label;

    #my $port_label;
    #if(scalar(@{$devices{$label}{free_uplinks}}) > 0) {
    #    $port_label = shift @{$devices{$label}{free_uplinks}};
    #}
    #
    #return $port_label;
#}


sub read_config_file {

    my @input;
    my $file = $conf;
    open(FILE,"<$file") or die("Couldn't open $file for reading");
        push @input, (<FILE>);
    close(FILE);
    push(@input, "");
    
    
    while(@input) {
        $_ = shift @input;
    
        # strip leading spaces
        s/^\s+//;
        
        if( m/^\[dimensions\]/ ) {
    
            #print "DEBUG: $_" if($debug);
    
            $_ = shift @input;
            until( m/$stanza_terminator/ ) {
                if(! m/^#/) {
                    chomp;
                    
                    m/(^\S+)\s+([\d\.]+)/;
                    my $var     = $1;
                    my $meters  = $2;
    
                    if( is_valid_number( $meters ) ) {

                        $dimensions{cold_isle}            = $meters if($var eq 'cold_isle');
                        $dimensions{hot_isle}             = $meters if($var eq 'hot_isle');
                        $dimensions{rack_unit}            = $meters if($var eq 'one_rack_unit');
                        $dimensions{cable_slack_to_port}  = $meters if($var eq 'cable_slack_to_port');
                        $dimensions{overhead_buffer}      = $meters if($var eq 'overhead_buffer');
                        $dimensions{under_floor_buffer}   = $meters if($var eq 'under_floor_buffer');
                        $dimensions{rack_width}           = $meters if($var eq 'rack_width');
                        $dimensions{rack_depth}           = $meters if($var eq 'rack_depth');

                    } else {

                        print "\n";
                        print "ERROR in config file:\n";
                        print "  $meters (value of $var) is not a valid number.\n";
                        print "\n";
                        exit 1;
                    }
                }
                $_ = shift @input;
            }
        }
    
        if( m/^\[floor_plan\]/ ) {
    
            #print "DEBUG: $_" if($debug);
    
            my $row = 1;
    
            $_ = shift @input;
            until( m/$stanza_terminator/ ) {
                if(! m/^#/) {
                    chomp;
    
                    my ($type, @racks) = split;
    
                    $floor_plan{row_type}{$row} = $type;
    
                    my $column = 1;
                    foreach my $rack (@racks) {
                        $floor_plan{racks}{$rack}{row}    = $row;
                        $floor_plan{racks}{$rack}{column} = $column;
                        $column++;
                    }
                    $row++;
                }
                $_ = shift @input;
            }
        }
    
    
        if( m/^\[cables\]/ ) {
    
            #print "DEBUG: $_" if($debug);
            #XXX handle quantity
    
            my $row = 1;
    
            $_ = shift @input;
            until( m/$stanza_terminator/ ) {
                if(! m/^#/) {
                    chomp;
                    my ($type, $length) = split;
                    $cables{$type}{$length} = $length;
                }
                $_ = shift @input;
            }
        }
    
    
        if( m/^\[devices\]/ ) {
    
            #print "DEBUG: $_" if($debug);
    
            my $row = 1;
    
            $_ = shift @input;
            until( m/$stanza_terminator/ ) {
                if(! m/^#/) {
                    chomp;
    
                    s/"//g;
                    s/'//g;
                    s/(\s+,|,\s+|\s+$)/,/g;
    
                    # HOSTNAME, TIER, RACKNAME, RACK_UNIT, EXTRA_ID, TOTAL_PORTS, UPLINK_PORTS, USED_PORTS_LIST, STRIPE, LAYOUT
                    my ($hostname, $tier, $rackname, $rackunit, $extra_id, $total_ports, $uplink_port_count, $used_ports_list, $stripe, $layout) = split(/,/);
    
                    $uplink_port_count = 0      unless($uplink_port_count =~ m/\d+/);
                    $stripe = 'yes'             unless($stripe =~ m/(yes|no)/i);
                    $layout = 'high-to-low'     unless($layout =~ m/(high-to-low|low-to-high|inside-out|outside-in)/i);
                    $extra_id = undef           unless($extra_id =~ m/\S/);
                    $used_ports_list = undef    unless($used_ports_list =~ m/\d/);
    
                    # Build name of device to be used on the label
                    my $label  = "$rackname-U$rackunit";
                    $label    .= "-$extra_id" if($extra_id);
    
                    my $used_ports = 0;
                    if($used_ports_list) {
                        $used_ports = scalar( split(/\s+/, $used_ports_list) );
                        print qq(DEBUG: $label used_ports_list "$used_ports_list", $used_ports used ports\n) if($debug);
                    }
    
                    # Derived value
                    my $downlink_port_count = $total_ports - $uplink_port_count - $used_ports;
    
                    # Object orient device
                    $devices{$label}{hostname}              = $hostname;
                    $devices{$label}{tier}                  = $tier;
                    $devices{tier}{$tier}{label}{$label}    = $hostname;
                    $devices{tier}{$tier}{rackname}{$rackname}{label}{$label} = $hostname;
                    $devices{$label}{rackname}              = $rackname;
                    $devices{$label}{rackunit}              = $rackunit;
                    $devices{$label}{extra_id}              = $extra_id if($extra_id);
                    $devices{$label}{total_ports}           = $total_ports;
                    $devices{$label}{uplink_port_count}     = $uplink_port_count;
                    $devices{$label}{downlink_port_count}   = $downlink_port_count;
                    $devices{tier}{$tier}{downlink_port_count} += $downlink_port_count;
                    $devices{$label}{used_ports_list}       = $used_ports_list if($used_ports_list);
                    $devices{$label}{stripe}                = $stripe;
                    $devices{$label}{layout}                = $layout;
    
                    # Define each port as an object and give it a value that represents it's state
                    initialize_used_port_objects($label);
                    initialize_uplink_port_objects($label);

                    if($downlink_port_count > 0) {
                        $devices{tier}{$tier}{downlink_device_count}++;
                        my $device_number = $devices{tier}{$tier}{downlink_device_count};
                        $devices{tier}{$tier}{downlink_devices}{$device_number} = $label;

                        initialize_downlink_port_objects($label);
                    }

                }
                $_ = shift @input;
            }
        }
    }
}


#sub create_ordered_list_of_downlinks_by_tier {
#return 1; #XXX
#    foreach my $tier ( sort keys %{$devices{tier}} ) {
#
#        my $downlink_ports_in_a_list = 0;
#
#        until( $downlink_ports_in_a_list == $devices{tier}{$tier}{downlink_port_count} ) {
#
#            foreach my $label (sort keys %{$devices{tier}{$tier}{label}}) {
#                #print "DEBUG: create_ordered_list_of_downlinks_by_tier(): label $label\n" if($debug and $tier == 2);
#
#                if( scalar(@{$devices{$label}{free_downlinks}{high}}) > 0 ) {
#
#                    my $port = shift @{$devices{$label}{free_downlinks}{high}};
#
#                   #push @{$devices{downlink_port_labels}{high}{$tier}}, "$label-$port_indicator$port";
#                    #print "DEBUG: Tier $tier, downlink_port_label_high $label-$port\n" if($debug and $tier == 2);
#
#                    $downlink_ports_in_a_list++;
#                }
#
#                if( scalar(@{$devices{$label}{free_downlinks}{low}}) > 0 ) {
#
#                    my $port = shift @{$devices{$label}{free_downlinks}{low}};
#
#                   #push @{$devices{downlink_port_labels}{low}{$tier}}, "$label-$port_indicator$port";
#                    #print "DEBUG: Tier $tier, downlink_port_label_low $label-$port\n" if($debug and $tier == 2);
#
#                    $downlink_ports_in_a_list++;
#                }
#            }
#            #print "DEBUG: Processed $downlink_ports_in_a_list tier $tier downlink ports out of $devices{tier}{$tier}{downlink_port_count}\n";
#        }
#        #print "DEBUG: create_ordered_list_of_downlinks_by_tier(): Tier $tier -- Processed $downlink_ports_in_a_list of $devices{tier}{$tier}{downlink_port_count} downlink ports\n";
#    }
#
##    foreach my $tier ( sort keys %{$devices{tier}} ) {
##        foreach my $port (@{$devices{downlink_port_labels}{high}{$tier}}) {
##            print "DOWN HIGH $tier $port\n";
##        }
##        foreach my $port (@{$devices{downlink_port_labels}{low}{$tier}}) {
##            print "DOWN LOW $tier $port\n";
##        }
##    }
#}


sub initialize_downlink_port_objects {

    my $label = shift;

    if($devices{$label}{downlink_port_count} > 0) {

        #    if($chosen_ports_count > $devices{$label}{total_ports} ) {
        #        print "FAIL!  $devices{$label}{hostname} port count doesn't add up...\n";
        #        print "       Please double-check your config file.\n";
        #        exit 1;
        #    }

        if( $devices{$label}{layout} eq 'high-to-low' ) {
            my $chosen_ports_count = 0;
            my $port = $devices{$label}{total_ports};
            until( $chosen_ports_count == $devices{$label}{downlink_port_count} ) {
                unless($devices{$label}{port}{$port}) {  # this exists if 'used'
                    $devices{$label}{port}{$port} = 'downlink';
                    push @{$devices{$label}{free_downlinks}{high}}, $port;
                    #print "DEBUG: $label $port\n" if($debug);
                    $chosen_ports_count++;
                }
                $port--;
            }
        }

        elsif( $devices{$label}{layout} eq 'low-to-high' ) {
            my $chosen_ports_count = 0;
            my $port = 1;
            until( $chosen_ports_count == $devices{$label}{downlink_port_count} ) {
                unless($devices{$label}{port}{$port}) {
                    $devices{$label}{port}{$port} = 'downlink';
                    push @{$devices{$label}{free_downlinks}{low}}, $port;
                    #print "DEBUG: $label $port\n" if($debug);
                    $chosen_ports_count++;
                }
                $port++;
            }
        }

        elsif( $devices{$label}{layout} eq 'outside-in' ) {

            my $downlink_port_count_high_side = sprintf "%.0g", $devices{$label}{downlink_port_count} / 2;
            my $downlink_port_count_low_side  = $devices{$label}{downlink_port_count} - $downlink_port_count_high_side;
            my $chosen_ports_count;
            my $port;

            # do low-to-center
            $chosen_ports_count = 0;
            $port = 1;
            until( $chosen_ports_count == $downlink_port_count_low_side ) {
                unless($devices{$label}{port}{$port}) {
                    $devices{$label}{port}{$port} = 'downlink';
                    push @{$devices{$label}{free_downlinks}{low}}, $port;
                    #print "DEBUG: $label $port\n" if($debug);
                    $chosen_ports_count++;
                }
                $port++;
            }

            # then high-to-center
            $chosen_ports_count = 0;
            $port = $devices{$label}{total_ports};
            until( $chosen_ports_count == $downlink_port_count_high_side ) {
                unless($devices{$label}{port}{$port}) {
                    $devices{$label}{port}{$port} = 'downlink';
                    push @{$devices{$label}{free_downlinks}{high}}, $port;
                    #print "DEBUG: $label $port\n" if($debug);
                    $chosen_ports_count++;
                }
                $port--;
            }
        }

        elsif( $devices{$label}{layout} eq 'inside-out' ) {

            my $downlink_port_count_high_side = sprintf "%.0g", $devices{$label}{downlink_port_count} / 2;
            my $downlink_port_count_low_side  = $devices{$label}{downlink_port_count} - $downlink_port_count_high_side;
            my $center_port_low = $devices{$label}{total_ports} / 2;
            my $center_port_high = $center_port_low + 1;

            my $chosen_ports_count;
            my $port;

            # do center-to-high
            $chosen_ports_count = 0;
            $port = $center_port_high;
            until( $chosen_ports_count == $downlink_port_count_high_side ) {
                unless($devices{$label}{port}{$port}) {
                    $devices{$label}{port}{$port} = 'downlink';
                    push @{$devices{$label}{free_downlinks}{high}}, $port;
                    #print "DEBUG: $label $port\n" if($debug);
                    $chosen_ports_count++;
                }
                $port++;
            }

            # then center-to-low
            $chosen_ports_count = 0;
            $port = $center_port_low;
            until( $chosen_ports_count == $downlink_port_count_low_side ) {
                unless($devices{$label}{port}{$port}) {
                    $devices{$label}{port}{$port} = 'downlink';
                    push @{$devices{$label}{free_downlinks}{low}}, $port;
                    #print "DEBUG: $label $port\n" if($debug);
                    $chosen_ports_count++;
                }
                $port--;
            }
        }
    }

    return 1;
}


sub initialize_uplink_port_objects {

    my $label = shift;

    if($devices{$label}{uplink_port_count} > 0) {

        if( $devices{$label}{layout} eq 'high-to-low' ) {
            my $chosen_ports_count = 0;
            my $port = $devices{$label}{total_ports};
            until( $chosen_ports_count == $devices{$label}{uplink_port_count} ) {
                unless($devices{$label}{port}{$port}) {  # this exists if 'used'
                    $devices{$label}{port}{$port} = 'uplink';
                    push @{$devices{$label}{free_uplinks}}, $port;
                    $chosen_ports_count++;
                }
                $port--;
            }
        }

        elsif( $devices{$label}{layout} eq 'low-to-high' ) {
            my $chosen_ports_count = 0;
            my $port = 1;
            until( $chosen_ports_count == $devices{$label}{uplink_port_count} ) {
                unless($devices{$label}{port}{$port}) {
                    $devices{$label}{port}{$port} = 'uplink';
                    push @{$devices{$label}{free_uplinks}}, $port;
                    $chosen_ports_count++;
                }
                $port++;
            }
        }

        elsif( $devices{$label}{layout} eq 'outside-in' ) {

            my $uplink_port_count_high_side = sprintf "%.0g", $devices{$label}{uplink_port_count} / 2;
            my $uplink_port_count_low_side  = $devices{$label}{uplink_port_count} - $uplink_port_count_high_side;
            my $chosen_ports_count;
            my $port;

            # do low-to-center
            $chosen_ports_count = 0;
            $port = 1;
            until( $chosen_ports_count == $uplink_port_count_low_side ) {
                unless($devices{$label}{port}{$port}) {
                    $devices{$label}{port}{$port} = 'uplink';
                    push @{$devices{$label}{free_uplinks}}, $port;
                    $chosen_ports_count++;
                }
                $port++;
            }

            # then high-to-center
            $chosen_ports_count = 0;
            $port = $devices{$label}{total_ports};
            until( $chosen_ports_count == $uplink_port_count_high_side ) {
                unless($devices{$label}{port}{$port}) {
                    $devices{$label}{port}{$port} = 'uplink';
                    push @{$devices{$label}{free_uplinks}}, $port;
                    $chosen_ports_count++;
                }
                $port--;
            }
        }

        elsif( $devices{$label}{layout} eq 'inside-out' ) {

            my $uplink_port_count_high_side = sprintf "%.0g", $devices{$label}{uplink_port_count} / 2;
            my $uplink_port_count_low_side  = $devices{$label}{uplink_port_count} - $uplink_port_count_high_side;
            my $center_port_low = $devices{$label}{total_ports} / 2;
            my $center_port_high = $center_port_low + 1;

            my $chosen_ports_count;
            my $port;

            # do center-to-high
            $chosen_ports_count = 0;
            $port = $center_port_high;
            until( $chosen_ports_count == $uplink_port_count_high_side ) {
                unless($devices{$label}{port}{$port}) {
                    $devices{$label}{port}{$port} = 'uplink';
                    push @{$devices{$label}{free_uplinks}}, $port;
                    $chosen_ports_count++;
                }
                $port++;
            }

            # then center-to-low
            $chosen_ports_count = 0;
            $port = $center_port_low;
            until( $chosen_ports_count == $uplink_port_count_low_side ) {
                unless($devices{$label}{port}{$port}) {
                    $devices{$label}{port}{$port} = 'uplink';
                    push @{$devices{$label}{free_uplinks}}, $port;
                    $chosen_ports_count++;
                }
                $port--;
            }
        }
    }

    return 1;
}


sub initialize_used_port_objects {

    my $label = shift;

    if($devices{$label}{used_ports_list}) {
        foreach my $port ( split(/\s+/, $devices{$label}{used_ports_list}) ) {
            $devices{$label}{port}{$port} = 'used';
        }
    }

    return 1;
}


exit 0;



########################################################################
#
#   BEGIN Subroutines
#
sub version {
    print qq(\n);
    print qq($progname v$version_number\n);
    print qq(\n);
    print qq(    Part of the "$pkgname" package\n);
    print qq(\n);

    return 1;
}

sub usage {
version();
print << "EOF";
Usage:  $progname --config-file FILE [OPTION...]

    Options can be abbreviated to minimum uniqueness.  For example, you
    could use "-h" or "--h" instead of "--help".

    --help

    --version

    --config-file FILE

        Where FILE contains tier1 and tier2 device entries in the
        following format.  Hash marks are fine within a section, but an
        empty line indicates the end of a section.


    --create-template

        Create a heavily commented config file template that can be used
        as an example and modified to meet your needs.


    --output-file FILE

        Resultant p2p information will be written to this file.  It is
        recommended that you have .csv at the end of the file name for
        ease of use with your spreadsheet or label maker software.

        Default: A new output file will be auto-chosen in /tmp.


    --cabling [above|below]

        If specified, cable lengths are calculated based on the information
        provided in the [floor_plan] stanza in the config file.

        LIMITATIONS:
            - Currently assumes one use devices.  So for switch chassis, name
              each leaf switch separately:

              R01-U36-L1
              R01-U36-L2
              R01-U35-L3
              R01-U35-L4
              etc.


    --columns NN

        Number of columns to use in output.

        Default: 1


    Support: 
    
        This software is provided as-is, with no express or implied
        support.  However, the author would love to receive your
        patches.  Please contact Brian E. Finley <bfinley\@lenovo.com>
        with patches and/or suggestions.


EOF
    return 1;
}


sub which {

    my $file = shift;
    my $path = shift;
    
    if( ! defined($path) ) { 
        $path = $ENV{PATH}; 
    }
    
    foreach my $dir (split(/:/,$path)) {
      if(-x "$dir/$file") {
        return "$dir/$file";
      }
    }
    return undef;
}

sub get_tmp_file {

    my $file;

    my $template_base = "/tmp/$progname";
    if($create_template) {
        $template_base .= ".INPUT_TEMPLATE";
    }
    my $cmd = qq(mktemp $template_base.XXX);

    open(INPUT,"$cmd|") or die("Couldn't run $cmd for input");
    while(<INPUT>) {
        if( m#^($template_base.*)# ) {
            $file = $1;
        }
    }
    close(INPUT);

    return $file;
}

sub user_is_root {

    if($< == 0) {
        return 1;
    }
    return undef;
}

#
# Schartzian Transformation Sort
#
#   Sorts the following as normally desired:
#
#       number1
#       number2
#       number10
#       number20
#       number100
#
sub schwartzian_sort {
    return map { $_->[0] }
    sort { $b->[1] <=> $a->[1]
               ||
           $a->[2] cmp $b->[2]
    } map { [$_, m/(\d+)$/, uc($_)] } @_;
}

sub create_template_file {

    my $output_file = shift;

    $output_file = get_tmp_file() unless($output_file);

    my $file = $output_file;
    open(FILE,">$file") or die("Coudn't open $file for writing");

    push @output, <<"EOF";
########################################################################
#
#   Template Instructions
#
########################################################################
#
#   - Edit this file, then use it as input to ${progname}.
#
#   - Configuration options
#
#       - DEVICE_NAME
#
#           The name of the switch or HCA device.  
#           
#           Here are some example best practice recommendations for a few device
#           types:
#
#             Unibody switch:
#
#               RACK-LOWEST_RACK_UNIT-PORT
#
#
#             Chassis switch -- treat each line card as a separate switch.  With
#             InfiniBand (circa 2015), they are actually separate switches.
#
#               RACK-LOWEST_RACK_UNIT-LINE_CARD-PORT
#
#
#             HCA card(s) in a node:
#
#               RACK-LOWEST_RACK_UNIT-HCA-PORT
#
#
#       - TOTAL_PORTS
#
#           Total number of ports on the switch or HCA.
#
#
#       - SPACE_DELIMITED_LIST_OF_USED_PORTS
#
#           List of ports already in use.  Order does not matter.  Leave blank
#           if no ports are already in use.
#
#
#       - TIER
#
#           Begin a stanza, one per network tier, with a list of switches in
#           that tier.
#           
#           Tier stanzas are delimited by a blank line.  If you have a blank
#           line in the middle of a stanza, that's where the stanza will
#           actually end.
#
#           Only two tiers are processed at a time.  So, if you have
#           three or more tiers in your network, you'll use multiple
#           config files.  For example, they might be named like this
#           for a three tier network:
#
#               FILE NAME       CONTENTS
#               ------------    ----------------
#               tier1-2.conf    leafs to spine
#               tier2-3.conf    nodes to leafs
#

########################################################################
#
#   Template Example
#
########################################################################
[dimensions]
#
#   All dimensions are in meters, except for rack_height_in_ru which is
#   specified in rack units.  This template includes the defaults, which are
#   used if not explicitly specified here.
#
cold_isle               3
hot_isle                2
one_rack_unit           .04445
cable_slack_to_port     .2
overhead_buffer         3.1691
under_floor_buffer      3.257999
rack_width              .6
rack_depth              1.2
rack_height_in_ru       42


[cable_choices]
#
#   TYPE    LENGTH
#
copper  .5
copper  1
copper  1.5
copper  2
copper  2.5
copper  3
copper  4
fiber   5
fiber   7
fiber   10
fiber   15
fiber   20
fiber   30


[floor_plan]
#
#   TYPE    [RACK1 RACK2 [RACK3...]]
#
#       Where TYPE = "racks", "cold_isle", or "hot_isle"
#       and RACK1 etc. is the rack name.
#
#   racks   R01 R02 R03 R04
#   cold_isle
#   racks   R05 R06 R07 R08
#   hot_isle
#   racks   R09 R10 R11 R12
#
racks   R01 R02 R03 R04

[cabling_methodology]
#
#   TIER    METHODOLOGY
#
#       Where METHODOLOGY is one of high-to-low, low-to-high, outside-in,
#       inside-out
#
#           - high-to-low (default): Uplinks on a 36port switch would be ports
#             19-36 for a 1:1 fabric.
#
#           - low-to-high: Uplinks on a 36port switch would be ports
#             1-18 for a 1:1 fabric.
#
#           - outside-in: Uplinks on a 36port switch would be ports 1-9 and
#             28-36 for a 1:1 fabric.  The left-most and right-most ports
#             (outside edge ports) will be used for uplinks, while the center
#             ports will be used for node links.  This works well if the leaf
#             switches are in the same rack as the spine switches.
#
#           - inside-out: Uplinks on a 36port switch would be ports
#             10-27 for a 1:1 fabric.  Opposite of outside-in.
#
tier1   high-to-low
tier2   high-to-low


[tier1]
#
#   DEVICE_NAME TOTAL_PORTS SPACE_DELIMITED_LIST_OF_USED_PORTS
#
R01-U05-L1 18 1 2 3 4 5 6 7 8
R01-U05-L2 18
R01-U05-L3 18

[devices]
#
# DEVICE,   TIER, RACKNAME, RACK_UNIT, EXTRA_ID, TOTAL_PORTS, UPLINK_PORTS, DOWNLINK_PORTS, USED_PORTS_LIST, STRIPE, LAYOUT
#
# sx6036-s1,   1,    R1,       31,        "",       36,          0,            36,             "",              [yes|no], high-to-low
# sx6036-s2,   1,    R1,       32,        "",       36,          0,            36,             "",              [yes|no], high-to-low
#
#
#   DEVICE is the name of the device you use as a hostname or on labels.  Note
#   that the info on the label is positional only (does not include the DEVICE
#   name), and is made up of {RACKNAME}-U{RACK_UNIT}-{EXTRA_ID}-P{PORT}.
#
#   STRIPE [yes|no] determins if this device's uplinks will be striped across
#   higher tier switches (e.g.: switch1-p1, switch2-p1, switch3-p1, etc.) or
#   not (e.g.: switch1-p1, switch1-p2, switch1-p3, etc.).  Default: "yes"
#
#   LAYOUT is a comma separated list that may include up to one of each of the
#   following settings:
#
#       high-to-low (default) -- Uplinks will start with the highest available
#       port on this switch, and iterate down.
#
#       low-to-high -- Opposite of high-to-low.
#
#       outside-in -- Uplinks will start with the outermost ports (highest
#       number and lowest number) and iterate in.  On a 36port leaf switch,
#       with 18 uplinks, the port selection would look like this:
#
#             Uplinks                                      Uplinks
#          ^^^^^^^^^^^^^                               ^^^^^^^^^^^^^^
#          1  3  5  7  9    11 13 15 17 19 21 23 25 27    29 31 33 35   Top ports
#          2  4  6  8    10 12 14 16 18 20 22 24 26    28 30 32 34 36   Bottom ports
#                        vvvvvvvvvvvvvvvvvvvvvvvvvvvvv
#                                  Downlinks
#
#       inside-out -- Opposite of outside-in.
#
#XXX need to complete this example
#




#
# Node with 2x dual-port adapters connected to tier1
#   Resulting ports that get assigned in output:
#       R02-U13-H1-1
#       R02-U13-H1-2
#       R02-U13-H2-1
#       R02-U13-H2-2

#       R02-U13-H1-1
#       R02-U13-H1-1
#       R02-U13-H1-1

#
R02-U13-H1 2 2 striped
R02-U13-H2 2 2 striped
#
#
# Node with only port 1 of a dual-port adapter connected to tier1 
#   Resulting ports that get assigned in output:
#       R02-U13-H1-1
#
R02-U13-H1 1 1
#
#
# Node with only port 2 of a dual-port adapter connected to tier1
#   Resulting ports that get assigned in output:
#       R02-U13-H1-2
#
R02-U13-H1 2 1
#
#
# 36port Leaf Switches in an iDataPlex rack
#   Resulting ports that get assigned in output:
#       R03-B-U8-25 - R03-B-U8-36
#
R03-B-U8 36 12
R03-D-U8 36 12
R03-D-U6 36 12
#
#
# 36port Leaf Switch in standard rack
#   Resulting ports that get assigned in output:
#       R04-U40-19 - R04-U40-36
#
R05-U40 36 18

EOF
    close(FILE);

    return 1;
}


sub print_output {

    my $file;

    if($output_file) {
        $file = $output_file;
    } else {
        $file = get_tmp_file();
    }
    
    open(FILE,">$file") or die("Coudn't open $file for writing");
    
        print FILE qq("$progname v$version_number"\n);
        print FILE qq("Part of '$pkgname'"\n);
    
        foreach(@output) {
            print FILE $_;
        }
        
        if($create_template) {
            print "Your $progname INPUT_TEMPLATE file can be found here:\n";
            print "\n";
            print "    $file\n";

        } else {

            #
            # Commentary
            #
            #print "\n";
            #print "Using $total_tier1_ports available ports across $tier1_count tier1 switches\n";
            #print "and $total_tier2_uplinks uplink ports across $tier2_count tier2 devices\n";
            print "\n";
            print "Using the following cable counts:\n";
            print "\n";
            foreach my $cable_type (sort keys %p2p_cable_counts) {
                print "    $cable_type:  $p2p_cable_counts{$cable_type}\n";
            }
            print "\n";
            print "Your label maker input file can be found here in .csv file format:\n";
            print "\n";
            print "    $file\n";
            print "\n";
            print "You can use this command to it in libreoffice right now:\n";
            print "\n";
            print qq(    libreoffice --calc "$file"\n);
            print "\n";
        }
        print "\n";
    
    close(FILE);
    
    #my $used_tier1_ports = keys %p2p_assignments;
    #print "\n# Tier2 devices consumed $used_tier1_ports of $total_tier1_ports available tier1 ports.\n" if(defined $debug);

    return 1;
}


sub is_valid_number {

    my $input = shift;

    if($input =~   
        m/
            ^           # Beginning of string
            [+-]?       # Optional plus or minus character
            (           # Followed by either:
              (           #   Start of first option
                \d+       #   One or more digits
                (\.\d*)?  #   Optionally followed by: one decimal point and zero or more digits
              )           #   End of first option
              |           # or
              (\.\d+)     #   One decimal point followed by one or more digits
            )           # End of grouping of the OR options
            $           # End of string (i.e. no extra characters remaining)
        /x              # Extended modifier (allows whitespace & comments in regular expression)
    ) {

        # It's a number!
        return 1;

    } else {

        # Not a number :-(
        return undef;
    }
}


sub choose_cable_length {

    my $device1 = shift;
    my $device2 = shift;

    my $rack1 = $devices{$device1}{rackname};
    my $rack2 = $devices{$device2}{rackname};

    my $ru1 = $devices{$device1}{rackunit};
    my $ru2 = $devices{$device2}{rackunit};

    # Remove any alpha info
    $ru1 =~ s/[a-z]//gi;
    $ru2 =~ s/[a-z]//gi;

    my $length;

    #
    # distance along row
    #
    # This could produce a negative number, but eh, that's ok, it still
    # represents relative distance -- multiply by 1 to make positive.  A zero
    # is OK too (same rack).
    #
    my $columns = ($floor_plan{racks}{$rack1}{column} - $floor_plan{racks}{$rack2}{column});
    $columns = abs($columns);
    $length = ($columns * $dimensions{rack_width});
    #print "DEBUG: choose_cable_length(): columns $columns\n" if($debug);

    # above/below
    if($rack1 ne $rack2) {
        if($cabling eq 'above') {
            $length += $dimensions{overhead_buffer};
        }
        elsif($cabling eq 'below') {
            $length += $dimensions{under_floor_buffer};
        }

        # distance down columns
        foreach my $row ($floor_plan{racks}{$rack1}{row}..$floor_plan{racks}{$rack2}{row}) {

            # think this is considered in cold and hot isle. -BEF-
            #if( $floor_plan{row_type}{$row} eq 'racks' ) {
            #    $length += $dimensions{rack_depth};
            #}
            if( $floor_plan{row_type}{$row} eq 'cold_isle' ) {
                $length += $dimensions{cold_isle};
            }
            elsif( $floor_plan{row_type}{$row} eq 'hot_isle' ) {
                $length += $dimensions{hot_isle};
            }
        }
    }

    # cable slack to port
    $length += ($dimensions{cable_slack_to_port} * 2);

    # vertical distance within rack
    my $vertical_distance;
    if($rack1 eq $rack2) {
        #print "Same Rack\n" if($debug);
        $vertical_distance += abs( ($ru1 - $ru2) * $dimensions{rack_unit} );
    } 
    elsif($cabling eq 'above') {
        #print "Other Rack, above\n" if($debug);
        $vertical_distance += (($dimensions{rack_height_in_ru} - $ru1) + ($dimensions{rack_height_in_ru} - $ru2)) * $dimensions{rack_unit};
    }
    elsif($cabling eq 'below') {
        #print "Other Rack, below\n" if($debug);
        $vertical_distance += ($ru1 + $ru2) * $dimensions{rack_unit};
    }
    $length += $vertical_distance;
    #print "DEBUG: vertical_distance $vertical_distance\n" if($debug);

    # Find the best cable for the job
    my $cable_length;
    if($rack1 eq $rack2) {
        # Within Rack, we try both, but prefer copper
        foreach my $cable (sort numerically keys %{$cables{copper}}) {

            if($cable > $length) {
                $cable_length = "${cable}m";
                #print "$device1 to $device2: Cable $cable is longer than $length\n" if($debug);
                last;
            }
        }

        #
        # If we didn't find a proper copper, try with a fiber too
        #
        unless($cable_length) {
            foreach my $cable (sort numerically keys %{$cables{fiber}}) {
                if($cable > $length) {
                    $cable_length = "${cable}m";
                    #print "$device1 to $device2: Cable $cable is longer than $length\n" if($debug);
                    last;
                }
            }
        }
    } else {
        # Rack to rack, we only use fiber
        foreach my $cable (sort numerically keys %{$cables{fiber}}) {
            if($cable > $length) {
                $cable_length = "${cable}m";
                #print "$device1 to $device2: Cable $cable is longer than $length\n" if($debug);
                last;
            }
        }
    }

    if($debug) {
        my $rounded_length = sprintf "%.2f", $length;
        print "Device: $device1 to $device2,\tLength: $rounded_length,\tCable Length: $cable_length\n";
    }

    if($cable_length) {
        return $cable_length 
    } else {
        return undef;
    }
}


sub create_output {

    print qq(DEBUG: create_output\n) if(defined $debug);

    my $line;
    my $column = 1;
    foreach my $lower_tier_label (reverse sort (keys %p2p_assignments) ) {
    
        my $port1_label = $p2p_assignments{$lower_tier_label}{port1_label};
        my $port2_label = $p2p_assignments{$lower_tier_label}{port2_label};
        my $cable_length = $p2p_assignments{$lower_tier_label}{cable_length};

        $line .= qq("$cable_length\n$port1_label\n$port2_label");

        if($column < $columns) {
            $line .= qq(,);    # Add the csv separator and track the column count
            $column++;
        } else {
            push @output, qq($line\n);
            $column = 1;    # Reset the column count
            $line = "";     # reset $line
        }
        #print "DEBUG: column => $column\n";
    }
    
    # Add a final carriage return
    push @output, "\n";

    return 1;
}


#sub assign_p2p_for_non_stripey_tier2_devices {
#    #
#    # Do non-stripey tier2 devices now (the default)
#    #
#    print qq(> begin "Do non-stripey tier2 devices now"\n) if(defined $debug);
#    foreach my $tier1_port (reverse schwartzian_sort (keys %tier1_ports) ) {
#    
#        #print qq(>> considering tier1_port $tier1_port\n) if(defined $debug);
#    
#        #
#        # Skip this entry if it's already defined
#        #
#        next if(defined $p2p_assignments{$tier1_port});
#    
#        #
#        # End loop if we've processed all the tier2 ports
#        #
#        last if(scalar(@tier2_ports) == 0 );
#    
#        my $tier2_port = shift @tier2_ports;
#        $p2p_assignments{$tier1_port} = $tier2_port;
#        print qq(>> assigning tier1_port $tier1_port to tier2_port $tier2_port\n) if(defined $debug);
#    }
#}


#sub assign_p2p_for_stripey_tier2_devices {
#    #
#    # Do stripey tier2 devices first
#    #
#    print qq(> begin "Do stripey tier2 devices first"\n) if(defined $debug);
#    while (@tier2_ports_to_be_striped) {
#    
#        foreach my $tier1_port (reverse schwartzian_sort (keys %tier1_ports) ) {
#        
#            #print qq(>> considering tier1_port $tier1_port\n) if(defined $debug);
#            $switch_name = $tier1_ports{$tier1_port};
#        
#            #
#            # Don't want to use a port on the same tier1 switch twice for this
#            # tier2 device.
#            #
#            next if($switch_name eq $last_switch_name);
#        
#            #
#            # Skip this entry if it's already defined
#            #
#            next if(defined $p2p_assignments{$tier1_port});
#    
#            #
#            # End loop if we've processed all the tier2 ports
#            #
#            last if( scalar(@tier2_ports_to_be_striped) == 0 );
#        
#            $_ = shift @tier2_ports_to_be_striped;
#        
#            my ($tier2_port, $stripe) = split(/\s+/, $_);
#        
#            $p2p_assignments{$tier1_port} = $tier2_port;
#            print qq(>> assigning tier1_port $tier1_port to tier2_port $tier2_port\n) if(defined $debug);
#        
#            # Remember which switch was last used
#            $last_switch_name = $switch_name;
#        }
#    }
#}


# Description:
# Modify a sort so that 10 comes after 2.  
# Standard sort: (sort $numbers);               # 1,10,2,3,4,5,6,7,8,9
# Numerically:   (sort numerically $numbers);   # 1,2,3,4,5,6,7,8,9,10
#
# Usage:
# foreach my $line (sort numerically (keys ( %{hash} )))
#
sub numerically {
    $a <=> $b;
}

#
#   END Subroutines
#
########################################################################
#   vim:set ts=4 ai et tw=0 number:
