#!/usr/bin/perl -w

#
# 2012.04.12  Brian Finley <bfinley@lenovo.com>
# - created to generate p2p labels for UChicago install by Rochester CSC
# 2014.01.13  Brian Finley <bfinley@lenovo.com>
# - updated to be more flexible
# - handle striping of some tier2 devices across a tier1 device
# - handle different uplink counts for each tier2 device
# - handle nodes directly connected to tier1 device (by treating as a tier2 with very
#   few ports)
# 2014.01.14  Brian Finley <bfinley@lenovo.com>
# - updated total number of tier1 device cards
# 2014.03.10  Brian Finley <bfinley@lenovo.com>
# - Added --force, --output-file, --columns
# 2015.02.05  Brian Finley <bfinley@lenovo.com>
#   - future comments to be added via the git log
#

use strict;
use Getopt::Long;
use File::Basename;
use Data::Dumper;

my $progname = basename($0);
my $pkgname = 'HPC Goodies';
my $version_number = '0.4.7';
my $pkg_url = 'https://github.com/finley/hpc-goodies';

my @ARGV_orig;
push @ARGV_orig, @ARGV;

our @output;

my $columns = 1;
GetOptions(
    "help"                  => \my $help,
    "version"               => \my $version,
    "v|verbose"             => \my $verbose,
    "columns=i"             =>    \$columns,
    "output-file=s"         => \my $output_file,
    "c|config|input-file=s" => \my $conf,
    "d|delimiter=s"         => \my $delimiter,
    "cabling|cables=s"      => \my $cabling,
    "debug"                 => \my $debug,
    "create-template"       => \my $create_template,
) or usage() and exit(1);

if ( defined $help ) {
    usage();
    exit 0;
}
elsif ( defined $version ) {
    version();
    exit 0;
}
elsif ( $create_template and $conf ) {
    usage();
    print "\n";
    print "  >> Try --create-template\n";
    print "      or --config\n";
    print "     but not both. ;-)\n";
    print "\n";
    exit 1;
}
elsif ( defined $create_template ) {
    create_template_file($output_file);
    print_output();
    exit 0;
}
elsif ( $cabling ) {

    $cabling = lc $cabling;

    unless($cabling =~ m/^(above|below)$/) {
        usage();
        print "\n";
        print "  >> Try --cabling above\n";
        print "      or --cabling below\n";
        print "\n";
        exit 1;
    }
}

if ( ! defined $conf ) {
    usage();
    print "\n";
    print "  >> Try --config FILENAME\n";
    print "      or --create-template\n";
    print "\n";
    exit 1;
}

$delimiter = '-' unless( defined $delimiter );

my %cables;
my %floor_plan;
my %devices;

# Assign defaults
my %dimensions;
$dimensions{cold_isle}           = 3;           # meters
$dimensions{hot_isle}            = 2;           # meters
$dimensions{rack_unit}           = .04445;      # meters
$dimensions{cable_slack_to_port} = .2;          # meters
$dimensions{overhead_buffer}     = 3.1691;      # meters
$dimensions{under_floor_buffer}  = 3.257999;    # meters
$dimensions{rack_width}          = .6;          # 1 floor tile  in meters
$dimensions{rack_depth}          = 1.2;         # 2 floor tiles in meters
$dimensions{rack_height_in_ru}   = 42;          # height in rack units
#
# TODO:
# - for each rack, indicate front or back cabling
# 


my $stanza_terminator = '^(\s+|$)';
my $comment = '^#';
my $port_indicator = 'P';

my %p2p_assignments;
my %p2p_cable_counts;
my %last_higher_tier_device_number_assigned;

read_config_file();
#    print Dumper($devices{'R3-U12-L'});
#    print Dumper($devices{'R4-U11'}); 
#    exit 7;
#create_ordered_list_of_downlinks_by_tier();
make_p2p_assignments();
create_output();
print_output();

exit 0;



sub make_p2p_assignments {

    foreach my $tier (reverse sort keys %{$devices{tier}}) {
        foreach my $lower_tier_label ( schwartzian_sort (keys %{$devices{tier}{$tier}{label}}) ) {

            next   unless(   $devices{$lower_tier_label}{free_uplinks}  );
            while( scalar @{$devices{$lower_tier_label}{free_uplinks}} > 0 ) {

                print "\nDEBUG: lower_tier_label $lower_tier_label\n" if($debug);

                my $port = shift @{$devices{$lower_tier_label}{free_uplinks}};
                my ($higher_tier_label, $higher_tier_port) = get_higher_tier_target_port($lower_tier_label, $port);

                print "DEBUG: higher_tier_label $higher_tier_label\n" if($debug);

                my $lower_tier_port_label  = $lower_tier_label  . $delimiter . $port_indicator . $port;
                my $higher_tier_port_label = $higher_tier_label . $delimiter . $port_indicator . $higher_tier_port;

                $devices{$lower_tier_label}{uplink_port_assignments}{$port}                 = $higher_tier_port_label;
                $devices{$higher_tier_label,}{downlink_port_assignments}{$higher_tier_port} = $lower_tier_port_label;

                $p2p_assignments{$lower_tier_port_label}{port1_label} = $lower_tier_port_label;
                $p2p_assignments{$lower_tier_port_label}{port2_label} = $higher_tier_port_label;

                if($cabling) {

                    my $cable_length = choose_cable_length($lower_tier_label, $higher_tier_label);
                    $p2p_assignments{$lower_tier_port_label}{cable_length} = $cable_length;
                    print "$cable_length uplink from $lower_tier_port_label -> $higher_tier_port_label\n" if($verbose);

                    $p2p_cable_counts{$cable_length}++;

                } else {

                    print "Uplink from $lower_tier_port_label -> $higher_tier_port_label\n" if($verbose);

                    $p2p_cable_counts{Unassigned}++;
                }

            } 
        }
    }

    return 1;
}


sub get_higher_tier_target_port {

    my $lower_tier_label    = shift;
    my $lower_tier_port     = shift;

    my $higher_tier = $devices{$lower_tier_label}{tier} - 1;

    my $side;
    my $other_side;
    if($devices{$lower_tier_label}{extra_id}) {    # must be a 1/2U node -- which side is it on?
        if($devices{$lower_tier_label}{extra_id} eq 'L') {
            $side = 'low';
            $other_side = 'high';
        } else {
            $side = 'high';
            $other_side = 'low';
        }
    } else {
        my $center_port_low = $devices{$lower_tier_label}{total_ports} / 2;    # E.g.: 18 on a 36port switch
        if($lower_tier_port > $center_port_low) {
            $side = 'high';
            $other_side = 'low';
        } else {
            $side = 'low';
            $other_side = 'high';
        }
    }

    my $higher_tier_label;
    my $higher_tier_port;

    my $device_number = 1;
    if($last_higher_tier_device_number_assigned{$lower_tier_label}) {
        $device_number = $last_higher_tier_device_number_assigned{$lower_tier_label} + 1;
    }
    elsif($last_higher_tier_device_number_assigned{'to-any-device'}) {
        $device_number = $last_higher_tier_device_number_assigned{'to-any-device'} + 1;
    }

    my $safety_count = 1;
    until($safety_count == $devices{tier}{$higher_tier}{downlink_device_count}) {  
        #
        # iterate until we've hit each higher tier device once
        #
        if($device_number > $devices{tier}{$higher_tier}{downlink_device_count}) {
            $device_number = 1;
        }

        $higher_tier_label = $devices{tier}{$higher_tier}{downlink_devices}{$device_number};

        # Prefer a port on the same side, but try the other side if not...
        if( scalar(@{$devices{$higher_tier_label}{free_downlinks}{$side}}) > 0 ) {
            $higher_tier_port = shift @{$devices{$higher_tier_label}{free_downlinks}{$side}};
            $last_higher_tier_device_number_assigned{$lower_tier_label} = $device_number;
            $last_higher_tier_device_number_assigned{'to-any-device'} = $device_number;
            return ($higher_tier_label, $higher_tier_port);
        } 
        elsif( scalar(@{$devices{$higher_tier_label}{free_downlinks}{$other_side}}) > 0 ) {
            $higher_tier_port = shift @{$devices{$higher_tier_label}{free_downlinks}{$other_side}};
            $last_higher_tier_device_number_assigned{$lower_tier_label} = $device_number;
            $last_higher_tier_device_number_assigned{'to-any-device'} = $device_number;
            return ($higher_tier_label, $higher_tier_port);
        }
        $device_number++;
        $safety_count++;
    }

    # if we get here, something went wrong
    print "ERROR in get_higher_tier_target_port()\n";
    exit 1;   
}


#
# Uplink Target is the port on the higher tier switch to which we will connect.
# The upstream end of the p2p.
#
# This subroutine is written from the perspective of the higher tier device
#
sub assign_uplink_targets {

    my $label = shift;

    my $chosen_ports_count = 0;
    until( $chosen_ports_count == $devices{$label}{uplink_port_count} ) {
        
        my $port1_label = get_next_free_uplink_port($label);
        my $port2_label = get_next_free_downlink_port($label, $port1_label);

        my $p2p = "$port1_label $port2_label";
        $p2p_assignments{$p2p}{port1_label} = $port1_label;
        $p2p_assignments{$p2p}{port2_label} = $port2_label;

        if($cabling) {
            my $cable_length = choose_cable_length($port1_label, $port2_label);
            $p2p_assignments{$p2p}{cable_length} = $cable_length;
        }

        $chosen_ports_count++;
    }

    return 1;
}


sub read_config_file {

    my @input;
    my $file = $conf;
    open(FILE,"<$file") or die("Couldn't open $file for reading");
        push @input, (<FILE>);
    close(FILE);
    push(@input, "");
    
    
    while(@input) {
        $_ = shift @input;
    
        # strip leading spaces
        s/^\s+//;
        
        if( m/^\[dimensions\]/ ) {
    
            #print "DEBUG: $_" if($debug);
    
            $_ = shift @input;
            until( m/$stanza_terminator/ ) {
                if(! m/^#/) {
                    chomp;
                    
                    m/(^\S+)\s+([\d\.]+)/;
                    my $var     = $1;
                    my $meters  = $2;
    
                    if( is_valid_number( $meters ) ) {

                        $dimensions{cold_isle}            = $meters if($var eq 'cold_isle');
                        $dimensions{hot_isle}             = $meters if($var eq 'hot_isle');
                        $dimensions{rack_unit}            = $meters if($var eq 'one_rack_unit');
                        $dimensions{cable_slack_to_port}  = $meters if($var eq 'cable_slack_to_port');
                        $dimensions{overhead_buffer}      = $meters if($var eq 'overhead_buffer');
                        $dimensions{under_floor_buffer}   = $meters if($var eq 'under_floor_buffer');
                        $dimensions{rack_width}           = $meters if($var eq 'rack_width');
                        $dimensions{rack_depth}           = $meters if($var eq 'rack_depth');

                    } else {

                        print "\n";
                        print "ERROR in config file:\n";
                        print "  $meters (value of $var) is not a valid number.\n";
                        print "\n";
                        exit 1;
                    }
                }
                $_ = shift @input;
            }
        }
    
        if( m/^\[floor_plan\]/ ) {
    
            #print "DEBUG: $_" if($debug);
    
            my $row = 1;
    
            $_ = shift @input;
            until( m/$stanza_terminator/ ) {
                if(! m/^#/) {
                    chomp;
    
                    my ($type, @racks) = split;
    
                    $floor_plan{row_type}{$row} = $type;
    
                    my $column = 1;
                    foreach my $rack (@racks) {
                        $floor_plan{racks}{$rack}{row}    = $row;
                        $floor_plan{racks}{$rack}{column} = $column;
                        $column++;
                    }
                    $row++;
                }
                $_ = shift @input;
            }
        }
    
    
        if( m/^\[cables\]/ ) {
    
            my $row = 1;
    
            $_ = shift @input;
            until( m/$stanza_terminator/ ) {
                if(! m/^#/) {
                    chomp;
                    my ($type, $length, $quantity) = split;

                    if( $type !~ m/^(copper|fiber)$/ ) {
                        print "\n";
                        print "ERROR: [cables] -> Invalid cable type specified in config file:\n";
                        print "\n";
                        print "  $_\n";
                        print "\n";

                        exit 1;

                    } elsif( ! is_valid_number($length) ) {
                        print "\n";
                        print "ERROR: [cables] -> Invalid cable length specified in config file:\n";
                        print "\n";
                        print "  $_\n";
                        print "\n";

                        exit 1;
                    }

                    if( ! is_valid_number($quantity) ) {
                        $quantity = 1000000000;
                        print "[cables] -> Quantity of available ${length}m $type cables not specified -- setting to default.\n" if($verbose or $debug);
                    }

                    print "[cables] -> Quantity of available ${length}m $type cables is set to $quantity\n" if($verbose or $debug);

                    $cables{$type}{$length} = $quantity;
                }
                $_ = shift @input;
            }
        }
    
    
        if( m/^\[devices\]/ ) {
    
            #print "DEBUG: $_" if($debug);
    
            my $row = 1;
    
            $_ = shift @input;
            until( m/$stanza_terminator/ ) {
                if(! m/^#/) {
                    chomp;
    
                    s/"//g;
                    s/'//g;
                    s/(\s+,|,\s+|\s+$)/,/g;
    
                    #    HOSTNAME, TIER,   RACKNAME, RACK_UNIT, EXTRA_ID, TOTAL_PORTS,    UPLINK_PORTS,       USED_PORTS_LIST, LAYOUT
                    my ($hostname, $tier, $rackname, $rackunit, $extra_id, $total_ports, $uplink_port_count, $used_ports_list, $layout) = split(/,/);
    
                    $uplink_port_count = 0      unless($uplink_port_count =~ m/\d+/);
                    $layout = 'high-to-low'     unless($layout and $layout =~ m/(high-to-low|low-to-high|inside-out|outside-in)/i);
                    $extra_id = undef           unless($extra_id and $extra_id =~ m/\S/);
                    $used_ports_list = undef    unless($used_ports_list and $used_ports_list =~ m/\d/);
    
                    # Build name of device to be used on the label
                    my $label  = $rackname . $delimiter . "U$rackunit";
                    $label    .= $delimiter . $extra_id if($extra_id);
    
                    my $used_ports = 0;
                    if($used_ports_list) {
                        $used_ports = scalar( split(/\s+/, $used_ports_list) );
                        print qq(DEBUG: $label used_ports_list "$used_ports_list", $used_ports used ports\n) if($debug);
                    }
    
                    # Derived value
                    my $downlink_port_count = $total_ports - $uplink_port_count - $used_ports;
    
                    # Object orient device
                    $devices{$label}{hostname}              = $hostname;
                    $devices{$label}{tier}                  = $tier;
                    $devices{tier}{$tier}{label}{$label}    = $hostname;
                    $devices{tier}{$tier}{rackname}{$rackname}{label}{$label} = $hostname;
                    $devices{$label}{rackname}              = $rackname;
                    $devices{$label}{rackunit}              = $rackunit;
                    $devices{$label}{extra_id}              = $extra_id if($extra_id);
                    $devices{$label}{total_ports}           = $total_ports;
                    $devices{$label}{uplink_port_count}     = $uplink_port_count;
                    $devices{$label}{downlink_port_count}   = $downlink_port_count;
                    $devices{tier}{$tier}{downlink_port_count} += $downlink_port_count;
                    $devices{$label}{used_ports_list}       = $used_ports_list if($used_ports_list);
                    $devices{$label}{layout}                = $layout;
    
                    # Define each port as an object and give it a value that represents it's state
                    initialize_used_port_objects($label);
                    initialize_uplink_port_objects($label);

                    if($downlink_port_count > 0) {
                        $devices{tier}{$tier}{downlink_device_count}++;
                        my $device_number = $devices{tier}{$tier}{downlink_device_count};
                        $devices{tier}{$tier}{downlink_devices}{$device_number} = $label;

                        initialize_downlink_port_objects($label);
                    }

                }
                $_ = shift @input;
            }
        }
    }
}


sub initialize_downlink_port_objects {

    my $label = shift;

    # Initialize array references so scalar tests don't fail
    @{$devices{$label}{free_downlinks}{high}} = ();
    @{$devices{$label}{free_downlinks}{low}}  = ();

    if($devices{$label}{downlink_port_count} > 0) {

        #    if($chosen_ports_count > $devices{$label}{total_ports} ) {
        #        print "FAIL!  $devices{$label}{hostname} port count doesn't add up...\n";
        #        print "       Please double-check your config file.\n";
        #        exit 1;
        #    }

        if( $devices{$label}{layout} eq 'high-to-low' ) {
            my $chosen_ports_count = 0;
            my $port = $devices{$label}{total_ports};
            until( $chosen_ports_count == $devices{$label}{downlink_port_count} ) {
                unless($devices{$label}{port}{$port}) {  # this exists if 'used'
                    $devices{$label}{port}{$port} = 'downlink';
                    push @{$devices{$label}{free_downlinks}{high}}, $port;
                    #print "DEBUG: $label $port\n" if($debug);
                    $chosen_ports_count++;
                }
                $port--;
            }
        }

        elsif( $devices{$label}{layout} eq 'low-to-high' ) {
            my $chosen_ports_count = 0;
            my $port = 1;
            until( $chosen_ports_count == $devices{$label}{downlink_port_count} ) {
                unless($devices{$label}{port}{$port}) {
                    $devices{$label}{port}{$port} = 'downlink';
                    push @{$devices{$label}{free_downlinks}{low}}, $port;
                    #print "DEBUG: $label $port\n" if($debug);
                    $chosen_ports_count++;
                }
                $port++;
            }
        }

        elsif( $devices{$label}{layout} eq 'outside-in' ) {

            my $downlink_port_count_high_side = sprintf "%.0g", $devices{$label}{downlink_port_count} / 2;
            my $downlink_port_count_low_side  = $devices{$label}{downlink_port_count} - $downlink_port_count_high_side;
            my $chosen_ports_count;
            my $port;

            # do low-to-center
            $chosen_ports_count = 0;
            $port = 1;
            until( $chosen_ports_count == $downlink_port_count_low_side ) {
                unless($devices{$label}{port}{$port}) {
                    $devices{$label}{port}{$port} = 'downlink';
                    push @{$devices{$label}{free_downlinks}{low}}, $port;
                    #print "DEBUG: $label $port\n" if($debug);
                    $chosen_ports_count++;
                }
                $port++;
            }

            # then high-to-center
            $chosen_ports_count = 0;
            $port = $devices{$label}{total_ports};
            until( $chosen_ports_count == $downlink_port_count_high_side ) {
                unless($devices{$label}{port}{$port}) {
                    $devices{$label}{port}{$port} = 'downlink';
                    push @{$devices{$label}{free_downlinks}{high}}, $port;
                    #print "DEBUG: $label $port\n" if($debug);
                    $chosen_ports_count++;
                }
                $port--;
            }
        }

        elsif( $devices{$label}{layout} eq 'inside-out' ) {

            my $downlink_port_count_high_side = sprintf "%.0g", $devices{$label}{downlink_port_count} / 2;
            my $downlink_port_count_low_side  = $devices{$label}{downlink_port_count} - $downlink_port_count_high_side;
            my $center_port_low = $devices{$label}{total_ports} / 2;
            my $center_port_high = $center_port_low + 1;

            my $chosen_ports_count;
            my $port;

            # do center-to-high
            $chosen_ports_count = 0;
            $port = $center_port_high;
            until( $chosen_ports_count == $downlink_port_count_high_side ) {
                unless($devices{$label}{port}{$port}) {
                    $devices{$label}{port}{$port} = 'downlink';
                    push @{$devices{$label}{free_downlinks}{high}}, $port;
                    #print "DEBUG: $label $port\n" if($debug);
                    $chosen_ports_count++;
                }
                $port++;
            }

            # then center-to-low
            $chosen_ports_count = 0;
            $port = $center_port_low;
            until( $chosen_ports_count == $downlink_port_count_low_side ) {
                unless($devices{$label}{port}{$port}) {
                    $devices{$label}{port}{$port} = 'downlink';
                    push @{$devices{$label}{free_downlinks}{low}}, $port;
                    #print "DEBUG: $label $port\n" if($debug);
                    $chosen_ports_count++;
                }
                $port--;
            }
        }
    }

    return 1;
}


sub initialize_uplink_port_objects {

    my $label = shift;

    # Initialize array references so scalar tests don't fail
    @{$devices{$label}{free_uplinks}} = ();

    if($devices{$label}{uplink_port_count} > 0) {

        if( $devices{$label}{layout} eq 'high-to-low' ) {
            my $chosen_ports_count = 0;
            my $port = $devices{$label}{total_ports};
            until( $chosen_ports_count == $devices{$label}{uplink_port_count} ) {
                unless($devices{$label}{port}{$port}) {  # this exists if 'used'
                    $devices{$label}{port}{$port} = 'uplink';
                    push @{$devices{$label}{free_uplinks}}, $port;
                    $chosen_ports_count++;
                }
                $port--;
            }
        }

        elsif( $devices{$label}{layout} eq 'low-to-high' ) {
            my $chosen_ports_count = 0;
            my $port = 1;
            until( $chosen_ports_count == $devices{$label}{uplink_port_count} ) {
                unless($devices{$label}{port}{$port}) {
                    $devices{$label}{port}{$port} = 'uplink';
                    push @{$devices{$label}{free_uplinks}}, $port;
                    $chosen_ports_count++;
                }
                $port++;
            }
        }

        elsif( $devices{$label}{layout} eq 'outside-in' ) {

            my $uplink_port_count_high_side = sprintf "%.0g", $devices{$label}{uplink_port_count} / 2;
            my $uplink_port_count_low_side  = $devices{$label}{uplink_port_count} - $uplink_port_count_high_side;
            my $chosen_ports_count;
            my $port;

            # do low-to-center
            $chosen_ports_count = 0;
            $port = 1;
            until( $chosen_ports_count == $uplink_port_count_low_side ) {
                unless($devices{$label}{port}{$port}) {
                    $devices{$label}{port}{$port} = 'uplink';
                    push @{$devices{$label}{free_uplinks}}, $port;
                    $chosen_ports_count++;
                }
                $port++;
            }

            # then high-to-center
            $chosen_ports_count = 0;
            $port = $devices{$label}{total_ports};
            until( $chosen_ports_count == $uplink_port_count_high_side ) {
                unless($devices{$label}{port}{$port}) {
                    $devices{$label}{port}{$port} = 'uplink';
                    push @{$devices{$label}{free_uplinks}}, $port;
                    $chosen_ports_count++;
                }
                $port--;
            }
        }

        elsif( $devices{$label}{layout} eq 'inside-out' ) {

            my $uplink_port_count_high_side = sprintf "%.0g", $devices{$label}{uplink_port_count} / 2;
            my $uplink_port_count_low_side  = $devices{$label}{uplink_port_count} - $uplink_port_count_high_side;
            my $center_port_low = $devices{$label}{total_ports} / 2;
            my $center_port_high = $center_port_low + 1;

            my $chosen_ports_count;
            my $port;

            # do center-to-high
            $chosen_ports_count = 0;
            $port = $center_port_high;
            until( $chosen_ports_count == $uplink_port_count_high_side ) {
                unless($devices{$label}{port}{$port}) {
                    $devices{$label}{port}{$port} = 'uplink';
                    push @{$devices{$label}{free_uplinks}}, $port;
                    $chosen_ports_count++;
                }
                $port++;
            }

            # then center-to-low
            $chosen_ports_count = 0;
            $port = $center_port_low;
            until( $chosen_ports_count == $uplink_port_count_low_side ) {
                unless($devices{$label}{port}{$port}) {
                    $devices{$label}{port}{$port} = 'uplink';
                    push @{$devices{$label}{free_uplinks}}, $port;
                    $chosen_ports_count++;
                }
                $port--;
            }
        }
    }

    return 1;
}


sub initialize_used_port_objects {

    my $label = shift;

    if($devices{$label}{used_ports_list}) {
        foreach my $port ( split(/\s+/, $devices{$label}{used_ports_list}) ) {
            $devices{$label}{port}{$port} = 'used';
        }
    }

    return 1;
}


exit 0;



########################################################################
#
#   BEGIN Subroutines
#
sub version {
    print qq(\n);
    print qq($progname v$version_number\n);
    print qq(Part of the "$pkgname" package\n);
    print qq($pkg_url\n);
    print qq(\n);

    return 1;
}

sub usage {
version();
print << "EOF";
Usage:  $progname --config-file FILE [OPTION...]

    Options can be abbreviated to minimum uniqueness.  For example, you
    could use "-h" or "--h" instead of "--help".

    --help

    --version

    --config-file FILE

        Where FILE contains tier1 and tier2 device entries in the
        following format.  Hash marks are fine within a section, but an
        empty line indicates the end of a section.

        If you don't have a config file yet, try --create-template.


    --delimiter DELIMITER

        Where DELIMITER is the character(s) that you want to separate each
        element in a device name on a label.  By default, a hyphen (-) is used
        and highly recommended for readability.

        Example:  R1-U8-P36


    --create-template

        Create a heavily commented config file template that can be used
        as an example and modified to meet your needs.


    --output-file FILE

        Resultant p2p information will be written to this file.  It is
        recommended that you have .csv at the end of the file name for
        ease of use with your spreadsheet or label maker software.

        Default: A new output file will be auto-chosen in /tmp.


    --cabling [above|below]

        If specified, cable lengths are calculated based on the information
        provided in the [floor_plan] stanza in the config file.

        NOTE:  For chassis switches, name each leaf module separately:

              R1-U36-L1
              R1-U36-L2
              R1-U35-L3
              R1-U35-L4
              etc.


    --columns NN

        Number of columns to use in output.

        Default: 1


    Support: 
    
        This software is provided as-is, with no express or implied
        support.  However, the author would love to receive your
        patches.  Please contact Brian E. Finley <bfinley\@lenovo.com>
        with patches and/or suggestions.


EOF
    return 1;
}


sub which {

    my $file = shift;
    my $path = shift;
    
    if( ! defined($path) ) { 
        $path = $ENV{PATH}; 
    }
    
    foreach my $dir (split(/:/,$path)) {
      if(-x "$dir/$file") {
        return "$dir/$file";
      }
    }
    return undef;
}

sub get_tmp_file {

    my $file;

    my $template_base = "/tmp/$progname";
    if($create_template) {
        $template_base .= ".INPUT_TEMPLATE";
    }
    my $cmd = qq(mktemp $template_base.XXX);

    open(INPUT,"$cmd|") or die("Couldn't run $cmd for input");
    while(<INPUT>) {
        if( m#^($template_base.*)# ) {
            $file = $1;
        }
    }
    close(INPUT);

    return $file;
}

sub user_is_root {

    if($< == 0) {
        return 1;
    }
    return undef;
}

#
# Schartzian Transformation Sort
#
#   Sorts the following as normally desired:
#
#       number1
#       number2
#       number10
#       number20
#       number100
#
# Usage:  schwartzian_sort (@array)
#
sub schwartzian_sort {
    return map { $_->[0] }
    sort { $b->[1] <=> $a->[1]
               ||
           $a->[2] cmp $b->[2]
    } map { [$_, m/(\d+)$/, uc($_)] } @_;
}

sub create_template_file {

    my $output_file = shift;

    $output_file = get_tmp_file() unless($output_file);

    my $file = $output_file;
    open(FILE,">$file") or die("Coudn't open $file for writing");

    push @output, <<"EOF";
########################################################################
#
#   $progname v$version_number
#
#   Part of the "$pkgname" package
#   https://github.com/finley/hpc-goodies
#
########################################################################
#
#   Template Instructions
#
########################################################################
#
#   - Edit this file, then use it as input to ${progname}.
#
#   - Configuration options
#
#       - HOSTNAME
#
#           The hostname of the switch or HCA device.  
#           
#           Here are some example best practice recommendations for a few device
#           types:
#
#             Unibody switch:
#
#               RACK-LOWEST_RACK_UNIT-PORT
#
#
#             Chassis switch -- treat each line card as a separate switch.  With
#             InfiniBand (circa 2015), they are actually separate switches.
#
#               RACK-LOWEST_RACK_UNIT-LINE_CARD-PORT
#
#
#             HCA card(s) in a node:
#
#               RACK-LOWEST_RACK_UNIT-HCA
#
#
#       - TOTAL_PORTS
#
#           Total number of ports on the switch or HCA.
#
#
#       - SPACE_DELIMITED_LIST_OF_USED_PORTS
#
#           List of ports already in use.  Order does not matter.  Leave blank
#           if no ports are already in use.
#
#
#       - TIER
#
#           Begin a stanza, one per network tier, with a list of switches in
#           that tier.
#           
#           Tier stanzas are delimited by a blank line.  If you have a blank
#           line in the middle of a stanza, that's where the stanza will
#           actually end.
#
#           Only two tiers are processed at a time.  So, if you have
#           three or more tiers in your network, you'll use multiple
#           config files.  For example, they might be named like this
#           for a three tier network:
#
#               FILE NAME       CONTENTS
#               ------------    ----------------
#               tier1-2.conf    leafs to spine
#               tier2-3.conf    nodes to leafs
#

########################################################################
#
#   Template Example
#
########################################################################
[dimensions]
#
#   All dimensions are in meters, except for rack_height_in_ru which is
#   specified in rack units.  This template includes the defaults, which are
#   used if not explicitly specified here.
#
cold_isle               3
hot_isle                2
one_rack_unit           .04445
cable_slack_to_port     .2
overhead_buffer         3.1691
under_floor_buffer      3.257999
rack_width              .6
rack_depth              1.2
rack_height_in_ru       42


[cable_choices]
#
#   TYPE    LENGTH  [QUANTITY]
#
#       If QUANTITY is omitted, an infinite supply is assumed.  Well, a really
#       big number is used anyway... (1000000000)
#
copper 0.5
copper 0.75
copper 1
copper 1.25
copper 1.5
copper 2
copper 3
fiber 3
fiber 5
fiber 10
fiber 15
fiber 20
fiber 30
fiber 50


[floor_plan]
#
#   TYPE    [RACK1 RACK2 [RACK3...]]
#
#       Where TYPE = "racks", "cold_isle", or "hot_isle"
#       and RACK1 etc. is the rack name.
#
#   racks   R1  R2  R3  R4
#   cold_isle
#   racks   R5  R6  R7  R8
#   hot_isle
#   racks   R9 R10 R11 R12
#
racks   R1 R2 R3 R4


[devices]
#
#   LAYOUT:
#
#       - high-to-low (default): Uplinks start with the highest available ports
#         and iterate down.  Paired downlinks are chosen in a matching way, if
#         possible.  On a 36port switch would be ports 19-36 for a 1:1 fabric.
#
#       - low-to-high: Opposite of high-to-low.
#
#       - outside-in -- Uplinks will start with the outermost ports (highest
#         number and lowest number) and iterate in.  This works well if the leaf
#         switches are in the same rack as the spine switches.  On a 36port leaf
#         switch, with 18 uplinks, the port selection would look like this:
#
#             Uplinks                                      Uplinks
#          ^^^^^^^^^^^^^                               ^^^^^^^^^^^^^^
#          1  3  5  7  9    11 13 15 17 19 21 23 25 27    29 31 33 35   Top ports
#          2  4  6  8    10 12 14 16 18 20 22 24 26    28 30 32 34 36   Bottom ports
#                        vvvvvvvvvvvvvvvvvvvvvvvvvvvvv
#                                  Downlinks
#
#       - inside-out: Opposite of outside-in.
#
#   EXTRA_ID:
#
#       - You can use this to indicate additional information to uniquely
#         idenfity a device in it's p2p output, such as L or R for left and
#         right on half-U nodes.
#
#
# HOSTNAME,   TIER, RACKNAME, RACK_UNIT, EXTRA_ID, TOTAL_PORTS, UPLINK_PORTS, USED_PORTS_LIST, LAYOUT
#
#   Spines
#
edr-spine1,    1,   R4,         22,         "",     36,         0,              "",              outside-in
edr-spine2,    1,   R4,         23,         "",     36,         0,              "",              outside-in
edr-spine3,    1,   R4,         24,         "",     36,         0,              "",              outside-in
#
edr-spine4,    1,   R4,         26,         "",     36,         0,              "",              outside-in
edr-spine5,    1,   R4,         27,         "",     36,         0,              "",              outside-in
edr-spine6,    1,   R4,         28,         "",     36,         0,              "",              outside-in
#
edr-spine7,    1,   R4,         30,         "",     36,         0,              "",              outside-in
edr-spine8,    1,   R4,         31,         "",     36,         0,              "",              outside-in
edr-spine9,    1,   R4,         32,         "",     36,         0,              "",              outside-in
#
#
#   Leafs
#
edr-leaf1,     2,   R4,         11,         "",     36,         18,             "",                 outside-in
edr-leaf2,     2,   R4,         12,         "",     36,         18,             "",                 outside-in
#
edr-leaf3,     2,   R4,         14,         "",     36,         18,             "",                 outside-in
edr-leaf4,     2,   R4,         15,         "",     36,         18,             "",                 outside-in
#
edr-leaf5,     2,   R4,         17,         "",     36,         18,             "",                 outside-in
edr-leaf6,     2,   R4,         18,         "",     36,         18,             "",                 outside-in
#
edr-leaf7,     2,   R4,         34,         "",     36,         18,             "",                 outside-in
edr-leaf8,     2,   R4,         35,         "",     36,         18,             "",                 outside-in
#
edr-leaf9,     2,   R4,         37,         "",     36,         18,             "",                 outside-in
edr-leaf10,    2,   R4,         38,         "",     36,         18,             "",                 outside-in
#
edr-leaf11,    2,   R4,         40,         "",     36,         18,             "",                 outside-in
edr-leaf12,    2,   R4,         41,         "",     36,         18,             "",                 outside-in
#
#
#   Nodes
#
# HOSTNAME, TIER, RACKNAME, RACK_UNIT, EXTRA_ID, TOTAL_PORTS, UPLINK_PORTS, USED_PORTS_LIST, LAYOUT
#
#                                                                           (for unspecified values the default is used)
#
nxt0101,    3,      R1,      3,        L,        1,           1
nxt0102,    3,      R1,      3,        R,        1,           1
nxt0103,    3,      R1,      4,        L,        1,           1
nxt0104,    3,      R1,      4,        R,        1,           1
nxt0105,    3,      R1,      5,        L,        1,           1
nxt0106,    3,      R1,      5,        R,        1,           1
nxt0107,    3,      R1,      6,        L,        1,           1
nxt0108,    3,      R1,      6,        R,        1,           1
nxt0109,    3,      R1,      7,        L,        1,           1
nxt0110,    3,      R1,      7,        R,        1,           1
nxt0111,    3,      R1,      8,        L,        1,           1
nxt0112,    3,      R1,      8,        R,        1,           1
nxt0113,    3,      R1,      9,        L,        1,           1
nxt0114,    3,      R1,      9,        R,        1,           1
nxt0115,    3,      R1,     10,        L,        1,           1
nxt0116,    3,      R1,     10,        R,        1,           1
nxt0117,    3,      R1,     11,        L,        1,           1
nxt0118,    3,      R1,     11,        R,        1,           1
nxt0119,    3,      R1,     12,        L,        1,           1
nxt0120,    3,      R1,     12,        R,        1,           1
nxt0121,    3,      R1,     13,        L,        1,           1
nxt0122,    3,      R1,     13,        R,        1,           1
nxt0123,    3,      R1,     14,        L,        1,           1
nxt0124,    3,      R1,     14,        R,        1,           1
nxt0125,    3,      R1,     15,        L,        1,           1
nxt0126,    3,      R1,     15,        R,        1,           1
nxt0127,    3,      R1,     16,        L,        1,           1
nxt0128,    3,      R1,     16,        R,        1,           1
nxt0129,    3,      R1,     17,        L,        1,           1
nxt0130,    3,      R1,     17,        R,        1,           1
nxt0131,    3,      R1,     18,        L,        1,           1
nxt0132,    3,      R1,     18,        R,        1,           1
nxt0133,    3,      R1,     19,        L,        1,           1
nxt0134,    3,      R1,     19,        R,        1,           1
nxt0135,    3,      R1,     20,        L,        1,           1
nxt0136,    3,      R1,     20,        R,        1,           1
nxt0137,    3,      R1,     23,        L,        1,           1
nxt0138,    3,      R1,     23,        R,        1,           1
nxt0139,    3,      R1,     24,        L,        1,           1
nxt0140,    3,      R1,     24,        R,        1,           1
nxt0141,    3,      R1,     25,        L,        1,           1
nxt0142,    3,      R1,     25,        R,        1,           1
nxt0143,    3,      R1,     26,        L,        1,           1
nxt0144,    3,      R1,     26,        R,        1,           1
nxt0145,    3,      R1,     27,        L,        1,           1
nxt0146,    3,      R1,     27,        R,        1,           1
nxt0147,    3,      R1,     28,        L,        1,           1
nxt0148,    3,      R1,     28,        R,        1,           1
nxt0149,    3,      R1,     29,        L,        1,           1
nxt0150,    3,      R1,     29,        R,        1,           1
nxt0151,    3,      R1,     30,        L,        1,           1
nxt0152,    3,      R1,     30,        R,        1,           1
nxt0153,    3,      R1,     31,        L,        1,           1
nxt0154,    3,      R1,     31,        R,        1,           1
nxt0155,    3,      R1,     32,        L,        1,           1
nxt0156,    3,      R1,     32,        R,        1,           1
nxt0157,    3,      R1,     33,        L,        1,           1
nxt0158,    3,      R1,     33,        R,        1,           1
nxt0159,    3,      R1,     34,        L,        1,           1
nxt0160,    3,      R1,     34,        R,        1,           1
nxt0201,    3,      R2,      3,        L,        1,           1
nxt0202,    3,      R2,      3,        R,        1,           1
nxt0203,    3,      R2,      4,        L,        1,           1
nxt0204,    3,      R2,      4,        R,        1,           1
nxt0205,    3,      R2,      5,        L,        1,           1
nxt0206,    3,      R2,      5,        R,        1,           1
nxt0207,    3,      R2,      6,        L,        1,           1
nxt0208,    3,      R2,      6,        R,        1,           1
nxt0209,    3,      R2,      7,        L,        1,           1
nxt0210,    3,      R2,      7,        R,        1,           1
nxt0211,    3,      R2,      8,        L,        1,           1
nxt0212,    3,      R2,      8,        R,        1,           1
nxt0213,    3,      R2,      9,        L,        1,           1
nxt0214,    3,      R2,      9,        R,        1,           1
nxt0215,    3,      R2,     10,        L,        1,           1
nxt0216,    3,      R2,     10,        R,        1,           1
nxt0217,    3,      R2,     11,        L,        1,           1
nxt0218,    3,      R2,     11,        R,        1,           1
nxt0219,    3,      R2,     12,        L,        1,           1
nxt0220,    3,      R2,     12,        R,        1,           1
nxt0221,    3,      R2,     13,        L,        1,           1
nxt0222,    3,      R2,     13,        R,        1,           1
nxt0223,    3,      R2,     14,        L,        1,           1
nxt0224,    3,      R2,     14,        R,        1,           1
nxt0225,    3,      R2,     15,        L,        1,           1
nxt0226,    3,      R2,     15,        R,        1,           1
nxt0227,    3,      R2,     16,        L,        1,           1
nxt0228,    3,      R2,     16,        R,        1,           1
nxt0229,    3,      R2,     17,        L,        1,           1
nxt0230,    3,      R2,     17,        R,        1,           1
nxt0231,    3,      R2,     18,        L,        1,           1
nxt0232,    3,      R2,     18,        R,        1,           1
nxt0233,    3,      R2,     19,        L,        1,           1
nxt0234,    3,      R2,     19,        R,        1,           1
nxt0235,    3,      R2,     20,        L,        1,           1
nxt0236,    3,      R2,     20,        R,        1,           1
nxt0237,    3,      R2,     23,        L,        1,           1
nxt0238,    3,      R2,     23,        R,        1,           1
nxt0239,    3,      R2,     24,        L,        1,           1
nxt0240,    3,      R2,     24,        R,        1,           1
nxt0241,    3,      R2,     25,        L,        1,           1
nxt0242,    3,      R2,     25,        R,        1,           1
nxt0243,    3,      R2,     26,        L,        1,           1
nxt0244,    3,      R2,     26,        R,        1,           1
nxt0245,    3,      R2,     27,        L,        1,           1
nxt0246,    3,      R2,     27,        R,        1,           1
nxt0247,    3,      R2,     28,        L,        1,           1
nxt0248,    3,      R2,     28,        R,        1,           1
nxt0249,    3,      R2,     29,        L,        1,           1
nxt0250,    3,      R2,     29,        R,        1,           1
nxt0251,    3,      R2,     30,        L,        1,           1
nxt0252,    3,      R2,     30,        R,        1,           1
nxt0253,    3,      R2,     31,        L,        1,           1
nxt0254,    3,      R2,     31,        R,        1,           1
nxt0255,    3,      R2,     32,        L,        1,           1
nxt0256,    3,      R2,     32,        R,        1,           1
nxt0257,    3,      R2,     33,        L,        1,           1
nxt0258,    3,      R2,     33,        R,        1,           1
nxt0259,    3,      R2,     34,        L,        1,           1
nxt0260,    3,      R2,     34,        R,        1,           1
nxt0301,    3,      R3,      3,        L,        1,           1
nxt0302,    3,      R3,      3,        R,        1,           1
nxt0303,    3,      R3,      4,        L,        1,           1
nxt0304,    3,      R3,      4,        R,        1,           1
nxt0305,    3,      R3,      5,        L,        1,           1
nxt0306,    3,      R3,      5,        R,        1,           1
nxt0307,    3,      R3,      6,        L,        1,           1
nxt0308,    3,      R3,      6,        R,        1,           1
nxt0309,    3,      R3,      7,        L,        1,           1
nxt0310,    3,      R3,      7,        R,        1,           1
nxt0311,    3,      R3,      8,        L,        1,           1
nxt0312,    3,      R3,      8,        R,        1,           1
nxt0313,    3,      R3,      9,        L,        1,           1
nxt0314,    3,      R3,      9,        R,        1,           1
nxt0315,    3,      R3,     10,        L,        1,           1
nxt0316,    3,      R3,     10,        R,        1,           1
nxt0317,    3,      R3,     11,        L,        1,           1
nxt0318,    3,      R3,     11,        R,        1,           1
nxt0319,    3,      R3,     12,        L,        1,           1
nxt0320,    3,      R3,     12,        R,        1,           1
nxt0321,    3,      R3,     13,        L,        1,           1
nxt0322,    3,      R3,     13,        R,        1,           1
nxt0323,    3,      R3,     14,        L,        1,           1
nxt0324,    3,      R3,     14,        R,        1,           1
nxt0325,    3,      R3,     15,        L,        1,           1
nxt0326,    3,      R3,     15,        R,        1,           1
nxt0327,    3,      R3,     16,        L,        1,           1
nxt0328,    3,      R3,     16,        R,        1,           1
nxt0329,    3,      R3,     17,        L,        1,           1
nxt0330,    3,      R3,     17,        R,        1,           1
nxt0331,    3,      R3,     18,        L,        1,           1
nxt0332,    3,      R3,     18,        R,        1,           1
nxt0333,    3,      R3,     19,        L,        1,           1
nxt0334,    3,      R3,     19,        R,        1,           1
nxt0335,    3,      R3,     20,        L,        1,           1
nxt0336,    3,      R3,     20,        R,        1,           1
nxt0337,    3,      R3,     23,        L,        1,           1
nxt0338,    3,      R3,     23,        R,        1,           1
nxt0339,    3,      R3,     24,        L,        1,           1
nxt0340,    3,      R3,     24,        R,        1,           1
nxt0341,    3,      R3,     25,        L,        1,           1
nxt0342,    3,      R3,     25,        R,        1,           1
nxt0343,    3,      R3,     26,        L,        1,           1
nxt0344,    3,      R3,     26,        R,        1,           1
nxt0345,    3,      R3,     27,        L,        1,           1
nxt0346,    3,      R3,     27,        R,        1,           1
nxt0347,    3,      R3,     28,        L,        1,           1
nxt0348,    3,      R3,     28,        R,        1,           1
nxt0349,    3,      R3,     29,        L,        1,           1
nxt0350,    3,      R3,     29,        R,        1,           1
nxt0351,    3,      R3,     30,        L,        1,           1
nxt0352,    3,      R3,     30,        R,        1,           1
nxt0353,    3,      R3,     31,        L,        1,           1
nxt0354,    3,      R3,     31,        R,        1,           1
nxt0355,    3,      R3,     32,        L,        1,           1
nxt0356,    3,      R3,     32,        R,        1,           1
nxt0357,    3,      R3,     33,        L,        1,           1
nxt0358,    3,      R3,     33,        R,        1,           1
nxt0359,    3,      R3,     34,        L,        1,           1
nxt0360,    3,      R3,     34,        R,        1,           1

EOF
    close(FILE);

    return 1;
}


sub print_output {

    my $file;

    if($output_file) {
        $file = $output_file;
    } else {
        $file = get_tmp_file();
    }
    
    open(FILE,">$file") or die("Coudn't open $file for writing");
    
        foreach(@output) {
            print FILE $_;
        }
        
        if($create_template) {
            print "Your $progname INPUT_TEMPLATE file can be found here:\n";
            print "\n";
            print "    $file\n";

        } else {

            #
            # Commentary
            #
            #print "\n";
            #print "Using $total_tier1_ports available ports across $tier1_count tier1 switches\n";
            #print "and $total_tier2_uplinks uplink ports across $tier2_count tier2 devices\n";

            my $longest_number = 0;
            foreach my $cable_type (sort keys %p2p_cable_counts) {
                my $length = length $p2p_cable_counts{$cable_type};
                if($length > $longest_number) {
                    $longest_number = $length;
                }
            }

            print "\n";
            print "Assigned the following cable counts:\n";
            print "\n";
            foreach my $cable_type (sort keys %p2p_cable_counts) {
                my $length = length $p2p_cable_counts{$cable_type};
                my $pad = space_pad( $longest_number - $length );
                print "    ${pad}$p2p_cable_counts{$cable_type} $cable_type cables\n";
            }
            print "\n";
            print "Your label maker input file can be found here in .csv file format:\n";
            print "\n";
            print "    $file\n";
            print "\n";
            print "You can use this command to it in libreoffice right now:\n";
            print "\n";
            print qq(    libreoffice --calc "$file"\n);
            print "\n";
        }
        print "\n";
    
    close(FILE);
    
    #my $used_tier1_ports = keys %p2p_assignments;
    #print "\n# Tier2 devices consumed $used_tier1_ports of $total_tier1_ports available tier1 ports.\n" if(defined $debug);

    return 1;
}


#
#   Usage:
#
#       if( is_valid_number( $meters ) ) { do stuff; }
#
sub is_valid_number {

    my $input = shift;

    if($input =~   
        m/
            ^           # Beginning of string
            [+-]?       # Optional plus or minus character
            (           # Followed by either:
              (           #   Start of first option
                \d+       #   One or more digits
                (\.\d*)?  #   Optionally followed by: one decimal point and zero or more digits
              )           #   End of first option
              |           # or
              (\.\d+)     #   One decimal point followed by one or more digits
            )           # End of grouping of the OR options
            $           # End of string (i.e. no extra characters remaining)
        /x              # Extended modifier (allows whitespace & comments in regular expression)
    ) {

        # It's a number!
        return 1;

    } else {

        # Not a number :-(
        return undef;
    }
}


sub choose_cable_length {

    my $device1 = shift;
    my $device2 = shift;

    unless($cabling) {
        return undef;
    }

    my $rack1 = $devices{$device1}{rackname};
    my $rack2 = $devices{$device2}{rackname};

    my $ru1 = $devices{$device1}{rackunit};
    my $ru2 = $devices{$device2}{rackunit};

    # Remove any alpha info
    $ru1 =~ s/[a-z]//gi;
    $ru2 =~ s/[a-z]//gi;

    my $distance;

    #
    # distance along row
    #
    # This could produce a negative number, but eh, that's ok, it still
    # represents relative distance -- multiply by 1 to make positive.  A zero
    # is OK too (same rack).
    #
    my $columns = ($floor_plan{racks}{$rack1}{column} - $floor_plan{racks}{$rack2}{column});
    $columns = abs($columns);
    $distance = ($columns * $dimensions{rack_width});
    #print "DEBUG: choose_cable_length(): columns $columns\n" if($debug);

    # above/below
    if($rack1 ne $rack2) {
        if($cabling eq 'above') {
            $distance += $dimensions{overhead_buffer};
        }
        elsif($cabling eq 'below') {
            $distance += $dimensions{under_floor_buffer};
        }

        # distance down columns
        foreach my $row ($floor_plan{racks}{$rack1}{row}..$floor_plan{racks}{$rack2}{row}) {

            # think this is considered in cold and hot isle. -BEF-
            #if( $floor_plan{row_type}{$row} eq 'racks' ) {
            #    $distance += $dimensions{rack_depth};
            #}
            if( $floor_plan{row_type}{$row} eq 'cold_isle' ) {
                $distance += $dimensions{cold_isle};
            }
            elsif( $floor_plan{row_type}{$row} eq 'hot_isle' ) {
                $distance += $dimensions{hot_isle};
            }
        }
    }

    # cable slack to port
    $distance += ($dimensions{cable_slack_to_port} * 2);

    # vertical distance within rack
    my $vertical_distance;
    if($rack1 eq $rack2) {
        #print "Same Rack\n" if($debug);
        $vertical_distance += abs( ($ru1 - $ru2) * $dimensions{rack_unit} );
    } 
    elsif($cabling eq 'above') {
        #print "Other Rack, above\n" if($debug);
        $vertical_distance += (($dimensions{rack_height_in_ru} - $ru1) + ($dimensions{rack_height_in_ru} - $ru2)) * $dimensions{rack_unit};
    }
    elsif($cabling eq 'below') {
        #print "Other Rack, below\n" if($debug);
        $vertical_distance += ($ru1 + $ru2) * $dimensions{rack_unit};
    }
    $distance += $vertical_distance;
    #print "DEBUG: vertical_distance $vertical_distance\n" if($debug);

    # Find the best cable for the job
    my $cable_length;
    my $cable_type;
    if($rack1 eq $rack2) {
        # Within Rack, we try both, but prefer copper
        $cable_type = 'copper';
        foreach my $length (sort numerically keys %{$cables{$cable_type}}) {

            next unless($cables{$cable_type}{$length} > 0);
            if($length > $distance) {
                $cable_length = "${length}m";
                $cables{$cable_type}{$length}--;

                #print "$device1 to $device2: Cable $length is greater than $distance\n" if($debug);
                print "Quantity of $cable_type ${length}m: $cables{$cable_type}{$length}\n" if($debug);
                last;
            }
        }

        #
        # If we didn't find a proper copper, try with a fiber too
        #
        unless($cable_length) {
            $cable_type = 'fiber';
            foreach my $length (sort numerically keys %{$cables{$cable_type}}) {
                next unless($cables{$cable_type}{$length} > 0);
                if($length > $distance) {
                    $cable_length = "${length}m";
                    $cables{$cable_type}{$length}--;
                    #print "$device1 to $device2: Cable $length is greater than $distance\n" if($debug);
                    print "Quantity of $cable_type ${length}m: $cables{$cable_type}{$length}\n" if($debug);
                    last;
                }
            }
        }

    } else {
        # Rack to rack, we only use fiber
        $cable_type = 'fiber';
        foreach my $length (sort numerically keys %{$cables{$cable_type}}) {
            next unless($cables{$cable_type}{$length} > 0);
            if($length > $distance) {
                $cable_length = "${length}m";
                $cables{$cable_type}{$length}--;
                #print "$device1 to $device2: Cable $length is greater than $distance\n" if($debug);
                print "Quantity of $cable_type ${length}m: $cables{$cable_type}{$length}\n" if($debug);
                last;
            }
        }
    }

    if($debug) {
        my $rounded_distance = sprintf "%.2f", $distance;
        print "Device: $device1 to $device2,\tDistance: ${rounded_distance}m,\tCable Length: $cable_length\n";
    }

    if($cable_length) {
        return $cable_length 
    } else {
        my $rounded_distance = sprintf "%.2f", $distance;
        print "WARNING: An appropriate cable length was unavailable for $device1 to $device2,\tDistance: ${rounded_distance}m\n";
        return undef;
    }
}


sub create_output {

    print qq(\nDEBUG: create_output\n) if(defined $debug);

    push @output, qq($progname v$version_number\n);
    push @output, qq(Part of the "$pkgname" package\n);
    push @output, qq(https://github.com/finley/hpc-goodies\n);
    push @output, qq(Output created with: @ARGV_orig\n);

    my $line;
    my $column = 1;
    foreach my $lower_tier_label (reverse sort (keys %p2p_assignments) ) {
    
        my $port1_label  = $p2p_assignments{$lower_tier_label}{port1_label};
        my $port2_label  = $p2p_assignments{$lower_tier_label}{port2_label};
        my $cable_length = $p2p_assignments{$lower_tier_label}{cable_length};

        if($cable_length) {
            $line .= qq("$cable_length\n$port1_label\n$port2_label");
        } else {
            $line .= qq("$port1_label\n$port2_label");
        }

        if($column < $columns) {
            $line .= qq(,);    # Add the csv separator and track the column count
            $column++;
        } else {
            push @output, qq($line\n);
            $column = 1;    # Reset the column count
            $line = "";     # reset $line
        }
        #print "DEBUG: column => $column\n";
    }
    
    # Add a final carriage return
    push @output, "\n";

    return 1;
}



# Description:
# Modify a sort so that 10 comes after 2.  
# Standard sort: (sort $numbers);               # 1,10,2,3,4,5,6,7,8,9
# Numerically:   (sort numerically $numbers);   # 1,2,3,4,5,6,7,8,9,10
#
# Usage:
# foreach my $line (sort numerically (keys ( %{hash} )))
#
sub numerically {
    $a <=> $b;
}

#
# Return a pad of spaces of N length.
#
#   my $pad = space_pad(N);
#
sub space_pad {

    my $space_count = shift;

    my $pad = "";
    my $i = 0;
    until($i == $space_count) {
        $pad .= " ";
        $i++;
    }
    return $pad;
}

#
#   END Subroutines
#
########################################################################
#   vim:set ts=4 ai et tw=0 number:
